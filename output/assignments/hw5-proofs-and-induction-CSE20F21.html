<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="author" content="CSE20F21" />
  <title>HW5 Proofs and Induction</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">HW5 Proofs and Induction</h1>
<p class="author">CSE20F21</p>
<p class="date">Due: Tuesday, November 16, 2021 at 11:00PM on
Gradescope</p>
</header>
<p><span><strong>In this assignment,</strong></span></p>
<p>You will work with recursively defined sets and functions and prove
properties about them, practicing induction and other proof
strategies.</p>
<p>Instructions and academic integrity reminders for all homework
assignments in CSE20 this quarter are on the class website and on the
hw1-definitions-and-notations assignment.</p>
<p>You will submit this assignment via Gradescope (<a
href="https://www.gradescope.com">https://www.gradescope.com</a>) in the
assignment called “hw5-proofs-and-induction”.</p>
<p><span><strong>Resources</strong></span>: To review the topics you are
working with for this assignment, see the class material from Weeks 5
through 7. We will post frequently asked questions and our answers to
them in a pinned Piazza post.</p>
<p>In your proofs and disproofs of statements below, justify each step
by reference to a component of the following proof strategies we have
discussed so far, and/or to relevant definitions and calculations.</p>
<ul>
<li><p>A counterexample can be used to prove that <span
class="math inline">\(\forall x P(x)\)</span> is
<span><strong>false</strong></span>.</p></li>
<li><p>A witness can be used to prove that <span
class="math inline">\(\exists x P(x)\)</span> is
<span><strong>true</strong></span>.</p></li>
<li><p><span><strong>Proof of universal by exhaustion</strong></span>:
To prove that <span class="math inline">\(\forall x \, P(x)\)</span> is
true when <span class="math inline">\(P\)</span> has a finite domain,
evaluate the predicate at <span><strong>each</strong></span> domain
element to confirm that it is always T.</p></li>
<li><p><span><strong>Proof by universal generalization</strong></span>:
To prove that <span class="math inline">\(\forall x \, P(x)\)</span> is
true, we can take an arbitrary element <span
class="math inline">\(e\)</span> from the domain and show that <span
class="math inline">\(P(e)\)</span> is true, without making any
assumptions about <span class="math inline">\(e\)</span> other than that
it comes from the domain.</p></li>
<li><p>To prove that <span class="math inline">\(\exists x P(x)\)</span>
is <span><strong>false</strong></span>, write the universal statement
that is logically equivalent to its negation and then prove it true
using universal generalization.</p></li>
<li><p><span><strong>Strategies for conjunction</strong></span>: To
prove that <span class="math inline">\(p \land q\)</span> is true, have
two subgoals: subgoal (1) prove <span class="math inline">\(p\)</span>
is true; and, subgoal (2) prove <span class="math inline">\(q\)</span>
is true. To prove that <span class="math inline">\(p \land q\)</span> is
false, it’s enough to prove that <span class="math inline">\(p\)</span>
is false. To prove that <span class="math inline">\(p \land q\)</span>
is false, it’s enough to prove that <span
class="math inline">\(q\)</span> is false.</p></li>
<li><p><span><strong>Proof of Conditional by Direct
Proof</strong></span>: To prove that the implication <span
class="math inline">\(p \to q\)</span> is true, we can assume <span
class="math inline">\(p\)</span> is true and use that assumption to show
<span class="math inline">\(q\)</span> is true.</p></li>
<li><p><span><strong>Proof of Conditional by Contrapositive
Proof</strong></span>: To prove that the implication <span
class="math inline">\(p \to q\)</span> is true, we can assume <span
class="math inline">\(\neg q\)</span> is true and use that assumption to
show <span class="math inline">\(\neg p\)</span> is true.</p></li>
<li><p><span><strong>Proof of disjuction using equivalent
conditional</strong></span>: To prove that the disjunction <span
class="math inline">\(p \lor q\)</span> is true, we can rewrite it
equivalently as <span class="math inline">\(\lnot p \to q\)</span> and
then use direct proof or contrapositive proof.</p></li>
<li><p><span><strong>Proof by Cases</strong></span>: To prove <span
class="math inline">\(q\)</span> when we know <span
class="math inline">\(p_1 \lor p_2\)</span>, show that <span
class="math inline">\(p_1 \to q\)</span> and <span
class="math inline">\(p_2 \to q\)</span>.</p></li>
<li><p><span><strong>Proof by Structural Induction</strong></span>: To
prove that <span class="math inline">\(\forall x \in X \, P(x)\)</span>
where <span class="math inline">\(X\)</span> is a recursively defined
set, prove two cases:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Basis Step:</td>
<td style="text-align: left;">Show the statement holds for elements
specified in the basis step of the definition.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Recursive Step:</td>
<td style="text-align: left;">Show that if the statement is true for
each of the elements used to construct new elements in the recursive
step of the definition, the result holds for these new elements.</td>
</tr>
</tbody>
</table></li>
<li><p><span><strong>Proof by Mathematical Induction</strong></span>: To
prove a universal quantification over the set of all integers greater
than or equal to some base integer <span
class="math inline">\(b\)</span>:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Basis Step:</td>
<td style="text-align: left;">Show the statement holds for <span
class="math inline">\(b\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Recursive Step:</td>
<td style="text-align: left;">Consider an arbitrary integer <span
class="math inline">\(n\)</span> greater than or equal to <span
class="math inline">\(b\)</span>, assume (as the <span><strong>induction
hypothesis</strong></span>) that the property holds for <span
class="math inline">\(n\)</span>, and use this and other facts to prove
that the property holds for <span
class="math inline">\(n+1\)</span>.</td>
</tr>
</tbody>
</table></li>
<li><p><span><strong>Proof by Strong Induction</strong></span> To prove
that a universal quantification over the set of all integers greater
than or equal to some base integer <span
class="math inline">\(b\)</span> holds, pick a fixed nonnegative integer
<span class="math inline">\(j\)</span> and then:</p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Basis Step:</td>
<td style="text-align: left;">Show the statement holds for <span
class="math inline">\(b\)</span>, <span
class="math inline">\(b+1\)</span>, …, <span
class="math inline">\(b+j\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;">Recursive Step:</td>
<td style="text-align: left;">Consider an arbitrary integer <span
class="math inline">\(n\)</span> greater than or equal to <span
class="math inline">\(b+j\)</span>, assume (as the <span><strong>strong
induction hypothesis</strong></span>) that the property holds for
<span><strong>each of</strong></span> <span
class="math inline">\(b\)</span>, <span
class="math inline">\(b+1\)</span>, …, <span
class="math inline">\(n\)</span>, and use this and other facts to prove
that the property holds for <span
class="math inline">\(n+1\)</span>.</td>
</tr>
</tbody>
</table></li>
<li><p><span><strong>Proof by Contradiction</strong></span></p>
<p>To prove that a statement <span class="math inline">\(p\)</span> is
true, pick another statement <span class="math inline">\(r\)</span> and
once we show that <span class="math inline">\(\neg p  \to (r
\wedge  \neg r)\)</span> then we can conclude that <span
class="math inline">\(p\)</span> is true.</p>
<p><span><em>Informally</em></span> The statement we care about can’t
possibly be false, so it must be true.</p></li>
</ul>
<p><span><strong>Assigned questions</strong></span></p>
<ol>
<li><p>Recall the definitions from class about factoring and
divisibility: when <span class="math inline">\(a\)</span> and <span
class="math inline">\(b\)</span> are integers and <span
class="math inline">\(a\)</span> is nonzero, <span><strong><span
class="math inline">\(a\)</span> divides <span
class="math inline">\(b\)</span></strong></span> means there is an
integer <span class="math inline">\(c\)</span> such that <span
class="math inline">\(b = ac\)</span> . In this case, we say <span
class="math inline">\(a\)</span> is a
<span><strong>factor</strong></span> of <span
class="math inline">\(b\)</span>, <span class="math inline">\(a\)</span>
is a <span><strong>divisor</strong></span> of <span
class="math inline">\(b\)</span>, <span class="math inline">\(b\)</span>
is a <span><strong>multiple</strong></span> of <span
class="math inline">\(a\)</span>, <span class="math inline">\(a |
b\)</span>. We define the function <span
class="math inline">\(PosFactors: \mathbb{Z}^+ \to
\mathcal{P}(\mathbb{Z}^+)\)</span> by <span
class="math display">\[PosFactors (n) = \{ x \in \mathbb{Z}^+ \mid
x\text{ is a factor of } n\}\]</span></p>
<hr />
<p><span><em>Sample calculation that can be used as reference for the
detail expected in your answer when working with this
function:</em></span></p>
<p>The function application <span
class="math inline">\(PosFactors(4)\)</span> evaluates to <span
class="math display">\[PosFactors (4) = \{ 1,2,4\}\]</span> because the
only possible positive factors of <span class="math inline">\(4\)</span>
are <span class="math inline">\(1,2,3,4\)</span> (the positive integers
less than or equal to <span class="math inline">\(4\)</span>) and when
we divide we get: <span class="math display">\[\begin{aligned}
        4 &amp;= 4 \cdot 1 + 0 \qquad \text{so $4$ is a factor of $4$}\\
        4 &amp;= 3 \cdot 1 + 1 \qquad \text{so $3$ is not a factor of
$4$}\\
        4 &amp;= 2 \cdot 2 + 0 \qquad \text{so $2$ is a factor of $4$}\\
        4 &amp;= 1 \cdot 4 + 0 \qquad \text{so $1$ is a factor of $4$}
   \end{aligned}\]</span></p>
<hr />
<ol>
<li><p>(<span><em>Graded for correctness</em></span><a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>)
Give a witness that proves the statement <span
class="math display">\[\exists x \in \mathbb{Z}^+ ~\forall y \in
\mathbb{Z}^+ ~\left(~x \in PosFactors(y)~\right)\]</span> Justify your
choice of witness by explanations that include references to the
relevant definitions.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Give a
counterexample that disproves the statement <span
class="math display">\[\forall n \in \mathbb{Z}^+ ~\left(~ PosFactors(n)
\subseteq PosFactors(n+1)~\right)\]</span> Justify your choice of
counterexample by explanations that include references to the relevant
definitions.</p></li>
<li><p>(<span><em>Graded for fair effort completeness</em></span>)
Consider the following attempted proof.</p>
<blockquote>
<p><span><strong>Attempted proof</strong></span>: For arbitrary integers
<span class="math inline">\(a, b, c\)</span>, assume towards a direct
proof that <span class="math inline">\((a+b) | c\)</span>. We need to
show that <span class="math inline">\(a|c\)</span> and <span
class="math inline">\(b | c\)</span>. Let <span
class="math inline">\(n\)</span> be the integer <span
class="math inline">\(c \text{\bf ~div~} (a+b)\)</span>. Since <span
class="math inline">\((a+b) | c\)</span>, by definition of divides,
<span class="math inline">\(n | c\)</span> and <span
class="math inline">\(n\)</span> is an integer. Since <span
class="math inline">\(c = 1 \cdot n \cdot (a+b)\)</span>, <span
class="math inline">\((n \cdot (a+b) ) | c\)</span>. Rewriting by
distributing multiplication over addition, we have <span
class="math inline">\(na | c\)</span> and <span class="math inline">\(nb
| c\)</span>. Since <span class="math inline">\(a | na\)</span> and
<span class="math inline">\(na | c\)</span>, we have <span
class="math inline">\(a | c\)</span>. Similarly, since <span
class="math inline">\(b | nb\)</span> and <span class="math inline">\(nb
| c\)</span>, we have <span class="math inline">\(b | c\)</span>. Thus,
we have proved both conjuncts and the proof is complete.</p>
</blockquote>
<p>Select the statement below that the attempted proof is trying to
prove.</p>
<ol>
<li><p><span class="math inline">\(\forall a \in \mathbb{Z}^+ ~\forall b
\in \mathbb{Z}^+ ~\forall c \in \mathbb{Z} ~( ~( ~a|c ~\lor~b |c~) ~\to~
(a+b) |c~)\)</span></p></li>
<li><p><span class="math inline">\(\forall a \in \mathbb{Z}^+ ~\forall b
\in \mathbb{Z}^+ ~\forall c \in \mathbb{Z} ~( ~( ~a|b ~\land~a |c~)
~\to~ a |(b+c)~)\)</span></p></li>
<li><p><span class="math inline">\(\forall a \in \mathbb{Z}^+ ~\forall b
\in \mathbb{Z}^+ ~\forall c \in \mathbb{Z} ~(~ (a+b) | c ~\to ~( ~a|c
~\land~b |c~)~)\)</span></p></li>
</ol>
<p>Identify the first major error in the attempted proof and explain why
it is incorrect.</p>
<p>Next, disprove the statement the attempted proof was attempting to
prove.</p>
<p><span><em>Extra practice; not for credit</em></span>: prove or
disprove the other two statements.</p></li>
</ol></li>
<li><p>In this question, we’ll consider the function which calculates
the sum of the first <span class="math inline">\(n\)</span> positive
integers.</p>
<ol>
<li><p>(<span><em>Graded for fair effort completeness</em></span><a
href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a>)</p>
<p>Give a recursive definition of this function, including domain,
codomain and both the basis step and recursive step of the rule. That
is, fill in the blanks <span class="math display">\[sumOfFirst:
\underline{~~domain~~} \to \underline{~~codomain}\]</span> given by
<span class="math display">\[\begin{aligned}
            &amp;\textbf{Basis step}: \underline{\text{fill in basis
step}} \\
            &amp;\textbf{Recursive step}: \underline{\text{fill in
recursive step}}
        \end{aligned}\]</span></p>
<p><span><em>Notation</em></span>: Using summation, this function can be
written <span class="math inline">\(sumOfFirst(n) = \sum_{i=1}^n
i\)</span>.<br />
</p></li>
<li><p>(<span><em>Graded for fair effort completeness</em></span>) It
turns out that the value of this function can also be calculated
explicitly (without recursion)<a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"><sup>3</sup></a>. You will prove this by
completing the proof of the identity <span
class="math display">\[\forall n \in \mathbb{Z}^+ ~\left(~sumOfFirst(n)
= \frac{n(n+1)}{2} \right)\]</span></p>
<p>Fill in the missing parts of the proof of this statement:<br />
<span><strong>Proof</strong></span>: We proceed by mathematical
induction on the set of positive integers.</p>
<p><span><strong>Basis Step</strong></span>: Choose <span
class="math inline">\(n = 1\)</span> as the basis step. Using the Basis
Step in the recursive definiton of <span
class="math inline">\(sumOfFirst\)</span>, <span
class="math inline">\(sumOfFirst(1) = 1\)</span>. Plugging <span
class="math inline">\(n\)</span> into the RHS of the desired formula,
<span class="math inline">\(\frac{1 (1+1)}{2} = \frac{2}{2} =
1\)</span>. Since LHS=RHS, the Basis step is complete.</p>
<p><span><strong>Recursive Step</strong></span>: Consider an arbitrary
<span class="math inline">\(k \geq 1\)</span>. We assume (as the
induction hypothesis) that <u>fill in the blank here</u>.</p>
<p>We want to show that <span class="math inline">\(sumOfFirst(k+1) =
\frac{(k + 1) \cdot ((k + 1) + 1)}{2}\)</span>.</p>
<p><u>Fill in the rest of the proof here.</u><br />
</p></li>
<li><p>(<span><em>Graded for fair effort completeness</em></span>) When
calculating the runtime of an algorithm, nested for loops sometimes lead
to program runtimes that involve the sum of the first <span
class="math inline">\(n\)</span> positive integers. To estimate the rate
of growth of this runtime, it is useful to find an upper bound for this
function in terms of a simpler function. Use the explicit formula from
the earlier parts of this question and mathematical induction to prove
<span class="math display">\[\forall n \in \mathbb{Z}^+~
\left(~sumOfFirst(n) \leq n^2 \right)\]</span></p></li>
</ol></li>
<li><p>Recall the definition of linked lists that we discussed in
class.</p>
<p>Define the function <span class="math inline">\(count\)</span> which
returns the number of occurrences of a datum in the list. Formally,
<span class="math inline">\(count: L \times \mathbb{N} \to
\mathbb{N}\)</span>, where <span class="math display">\[\begin{aligned}
    \textbf{Basis Step:} \qquad &amp;\textrm{If } m \in \mathbb{N},~~
count(~( [], m)~ ) = 0 \\
    \textbf{Recursive Step:} \qquad &amp;\textrm{If } l \in L\textrm{
and }n \in \mathbb{N}
    \textrm{ and }m \in \mathbb{N} \textrm{, then  } \\
    &amp;count(~(~(n, l),m~)~ ) =
        \begin{cases}
            1 + count(~(l,m)~) &amp;\text{if $n=m$} \\
            count(~(l,m)~) &amp;\text{otherwise} \\
        \end{cases}
    \end{aligned}\]</span></p>
<p>A mystery function is defined by <span class="math inline">\(mystery
: L \times \mathbb{N} \to L\)</span>, where</p>
<p><span class="math display">\[\begin{aligned}
    \textbf{Basis Step:} \qquad &amp;\textrm{If } m \in \mathbb{N},~~
mystery(~( [], m)~ ) = [] \\
    \textbf{Recursive Step:} \qquad &amp;\textrm{If } l \in L\textrm{
and }n \in \mathbb{N}
    \textrm{ and }m \in \mathbb{N} \textrm{, then  } \\
    &amp;mystery(~(~(n, l),m~)~ ) =
        \begin{cases}
            l &amp;\text{if $n=m$} \\
            mystery(~(l,m)~) &amp;\text{otherwise} \\
        \end{cases}
    \end{aligned}\]</span></p>
<ol>
<li><p>(<span><em>Graded for correctness</em></span>) Prove that <span
class="math display">\[\forall m \in \mathbb{N}~ \exists l \in L ~\left(
count(~(l,20)~) = m~ \right)\]</span></p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Give an example
input <span class="math inline">\(x\)</span> to the function such that
<span class="math display">\[mystery( ~(~ x ~,~ 2~) ~) = []\]</span> For
full credit, include all intermediate steps of the function application
that justifies your choice of <span class="math inline">\(x\)</span>,
with brief justifications for each.</p></li>
<li><p>(<span><em>Graded for correctness</em></span>) Evaluate the
function application <span class="math display">\[mystery( ~(~ (2, (0,
(2, []) ) ) ~,~ 2~) ~)\]</span> For full credit, include all
intermediate steps of the function application, with brief
justifications for each.</p></li>
<li><p>(<span><em>Graded for fair effort completeness for English
statements and correctness in use of syntax for symbolic
statements</em></span>) Describe the rule of the function <span
class="math inline">\(mystery\)</span> in English. Then, write a true
statement that describes an invariant using both the functions <span
class="math inline">\(mystery\)</span> and <span
class="math inline">\(count\)</span>. Express this invariant both
symbolically and in English.</p></li>
</ol></li>
</ol>
<section class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Graded for correctness means your
solution will be evaluated not only on the correctness of your answers,
but on your ability to present your ideas clearly and logically. You
should explain how you arrived at your conclusions, using mathematically
sound reasoning. Whether you use formal proof techniques or write a more
informal argument for why something is true, your answers should always
be well-supported. Your goal should be to convince the reader that your
results and methods are sound.<a href="#fnref1" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Graded for fair effort completeness
means you will get full credit so long as your submission demonstrates
honest effort to answer the question. You will not be penalized for
incorrect answers.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>When the value of a function that is
recursively defined can also be calculated without recursion, we call
the formula that we can use to calculate the value without recursion the
“closed form formula” for the function.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
</body>
</html>
