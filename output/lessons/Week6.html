<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Week6</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <script
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js"
  type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<div class="flushright">

</div>
<h1 class="unnumbered" id="monday-november-1">Monday November 1</h1>
<p>Today’s session is on Zoom, log in with your @ucsd.edu account
https://ucsd.zoom.us/j/97431852722 Meeting ID: 974 3185 2722</p>
<p><span><em>Recall the definitions</em></span>: The set of RNA strands
<span class="math inline">\(S\)</span> is defined (recursively) by:
<span class="math display">\[\begin{array}{ll}
\textrm{Basis Step: } &amp; \texttt{A}\in S, \texttt{C}\in S,
\texttt{U}\in S, \texttt{G}\in S \\
\textrm{Recursive Step: } &amp; \textrm{If } s \in S\textrm{ and }b \in
B \textrm{, then }sb \in S
\end{array}\]</span> where <span class="math inline">\(sb\)</span> is
string concatenation.</p>
<p>The function <em>rnalen</em> that computes the length of RNA strands
in <span class="math inline">\(S\)</span> is defined recursively by:
<span class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{rnalen} : S &amp; \to \mathbb{Z}^+ \\
\textrm{Basis Step:} &amp; \textrm{If } b \in B\textrm{ then } &amp;
\textit{rnalen}(b) &amp; = 1 \\
\textrm{Recursive Step:} &amp; \textrm{If } s \in S\textrm{ and }b \in
B\textrm{, then  } &amp; \textit{rnalen}(sb) &amp; = 1 +
\textit{rnalen}(s)
\end{array}\]</span></p>
<p>The function <em>basecount</em> that computes the number of a given
base <span class="math inline">\(b\)</span> appearing in a RNA strand
<span class="math inline">\(s\)</span> is defined recursively by: <span
class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{basecount} : S \times B &amp; \to \mathbb{N} \\
\textrm{Basis Step:} &amp;  \textrm{If } b_1 \in B, b_2 \in B &amp;
\textit{basecount}(~(b_1, b_2)~) &amp; =
        \begin{cases}
            1 &amp; \textrm{when } b_1 = b_2 \\
            0 &amp; \textrm{when } b_1 \neq b_2 \\
        \end{cases} \\
\textrm{Recursive Step:} &amp; \textrm{If } s \in S, b_1 \in B, b_2 \in
B &amp;\textit{basecount}(~(s b_1, b_2)~) &amp; =
        \begin{cases}
            1 + \textit{basecount}(~(s, b_2)~) &amp; \textrm{when } b_1
= b_2 \\
            \textit{basecount}(~(s, b_2)~) &amp; \textrm{when } b_1 \neq
b_2 \\
        \end{cases}
\end{array}\]</span></p>
<p>At this point, we’ve seen the proof strategies</p>
<div class="multicols">
<p><span>2</span></p>
<ul>
<li><p>A <span><strong>counterexample</strong></span> to prove that
<span class="math inline">\(\forall x P(x)\)</span> is
<span><strong>false</strong></span>.</p></li>
<li><p>A <span><strong>witness</strong></span> to prove that <span
class="math inline">\(\exists x P(x)\)</span> is
<span><strong>true</strong></span>.</p></li>
<li><p><span><strong>Proof of universal by exhaustion</strong></span> to
prove that <span class="math inline">\(\forall x \, P(x)\)</span> is
true when <span class="math inline">\(P\)</span> has a finite
domain</p></li>
<li><p><span><strong>Proof by universal generalization</strong></span>
to prove that <span class="math inline">\(\forall x \, P(x)\)</span> is
true using an arbitrary element of the domain.</p></li>
<li><p>To prove that <span class="math inline">\(\exists x P(x)\)</span>
is <span><strong>false</strong></span>, write the universal statement
that is logically equivalent to its negation and then prove it true
using universal generalization.</p></li>
<li><p>To prove that <span class="math inline">\(p \land q\)</span> is
true, have two subgoals: subgoal (1) prove <span
class="math inline">\(p\)</span> is true; and, subgoal (2) prove <span
class="math inline">\(q\)</span> is true. To prove that <span
class="math inline">\(p \land q\)</span> is false, it’s enough to prove
that <span class="math inline">\(p\)</span> is false. To prove that
<span class="math inline">\(p \land q\)</span> is false, it’s enough to
prove that <span class="math inline">\(q\)</span> is false.</p></li>
<li><p>Proof of conditional by <span><strong>direct
proof</strong></span></p></li>
<li><p>Proof of conditional by <span><strong>contrapositive
proof</strong></span></p></li>
<li><p>Proof of disjuction using equivalent conditional: To prove that
the disjunction <span class="math inline">\(p \lor q\)</span> is true,
we can rewrite it equivalently as <span class="math inline">\(\lnot p
\to q\)</span> and then use direct proof or contrapositive
proof.</p></li>
<li><p><span><strong>Proof by cases</strong></span>.</p></li>
</ul>
</div>
<p>Which proof strategies could be used to prove each of the following
statements?</p>
<p><span><em>Hint: first translate the statements to English and
identify the main logical structure.</em></span></p>
<p><span class="math inline">\(\forall s \in S~(~rnalen(s) &gt;
0~)\)</span></p>
<p><span class="math inline">\(\forall b \in B~\exists s \in
S~(~basecount(~(s,b)~)~ &gt; 0~)\)</span></p>
<p><span class="math inline">\(\forall s \in S ~\exists b\in B
~(~basecount(~(s,b)~) &gt; 0~)\)</span></p>
<p><span class="math inline">\(\exists s \in S \, (\textit{rnalen(s)} =
\textit{basecount}(~(s, \texttt{A})~)\)</span></p>
<p><span class="math inline">\(\forall s \in S \, (\textit{rnalen(s)}
\geq \textit{basecount}(~(s, \texttt{A})~))\)</span></p>
<p><span><strong>Claim</strong></span> <span
class="math inline">\(\forall s \in S ~(~rnalen(s) &gt; 0~)\)</span></p>
<p><span><strong>Proof</strong></span>: Let <span
class="math inline">\(s\)</span> be an arbitrary RNA strand. By the
recursive definition of <span class="math inline">\(S\)</span>, either
<span class="math inline">\(s \in B\)</span> or there is some strand
<span class="math inline">\(s_0\)</span> and some base <span
class="math inline">\(b\)</span> such that <span class="math inline">\(s
= s_0 b\)</span>. We will show that the inequality holds for both
cases.</p>
<p><span><span class="math inline">\(\phantom{Basis}\)</span></span>
<span><strong>Case</strong></span>: Assume <span class="math inline">\(s
\in B\)</span>. We need to show <span class="math inline">\(rnalen(s)
&gt; 0\)</span>. By the basis step in the definition of <span
class="math inline">\(rnalen\)</span>, <span
class="math display">\[rnalen(s) = 1\]</span> which is greater than
<span class="math inline">\(0\)</span>, as required.</p>
<p><span><span class="math inline">\(\phantom{Recursive}\)</span></span>
<span><strong>Case</strong></span>: Assume there is some strand <span
class="math inline">\(s_0\)</span> and some base <span
class="math inline">\(b\)</span> such that <span class="math inline">\(s
= s_0 b\)</span>. We will show <span><em>(the stronger
claim)</em></span> that <span class="math display">\[\forall u \in S
~\forall b \in B ~( ~\textit{rnalen}(u) &gt;0  \to
    \textit{rnalen}(ub) &gt;0 ~)\]</span> Consider an arbitrary RNA
strand <span class="math inline">\(u\)</span> and an arbitrary base
<span class="math inline">\(b\)</span>, and assume towards a direct
proof,<span class="math inline">\(~~{\phantom{ this is the induction
hypothesis}}~~\)</span> that <span class="math display">\[rnalen(u) &gt;
0\]</span> We need to show that <span class="math inline">\(rnalen(ub)
&gt; 0\)</span>. <span class="math display">\[rnalen(ub) = 1 + rnalen
(u) &gt; 1 + 0 = 1 &gt; 0\]</span> as required.</p>
<p><span><strong>Claim</strong></span> <span
class="math inline">\(\forall s \in S \, (\textit{rnalen(s)} \geq
\textit{basecount}(~(s, \texttt{A})~))\)</span>:</p>
<p><span><strong>Proof</strong></span>: We proceed by structural
induction on the recursively defined set <span
class="math inline">\(S\)</span>.</p>
<p><span><strong>Basis Case</strong></span>: We need to prove that the
inequality holds for each element in the basis step of the recursive
definition of <span class="math inline">\(S\)</span>. Need to show <span
class="math display">\[\begin{aligned}
          &amp;(~ rnalen(\texttt{A}) \geq basecount(~(\texttt{A},
\texttt{A})~)~) \land (~ rnalen(\texttt{C}) \geq basecount(~(\texttt{C},
\texttt{A})~)~) \\
    \land &amp; (~ rnalen(\texttt{U}) \geq basecount(~(\texttt{U},
\texttt{A})~)~) \land (~ rnalen(\texttt{G}) \geq basecount(~(\texttt{G},
\texttt{A})~)~)\end{aligned}\]</span> We calculate, using the
definitions of <span class="math inline">\(rnalen\)</span> and <span
class="math inline">\(basecount\)</span>:</p>
<p><span><strong>Recursive Case</strong></span>: We will prove that
<span class="math display">\[\forall u \in S ~\forall b \in B ~(
~rnalen(u) \geq basecount(~(u, \texttt{A})~) \to
    rnalen(ub) \geq basecount(~(ub, \texttt{A})~)\]</span></p>
<p>Consider arbitrary RNA strand <span class="math inline">\(u\)</span>
and arbitrary base <span class="math inline">\(b\)</span>. Assume, as
the <span><strong>induction hypothesis</strong></span>, that <span
class="math inline">\(rnalen(u) \geq
basecount(~(u,\texttt{A})~)\)</span>. We need to show that <span
class="math inline">\(rnalen(ub) \geq basecount(~(ub,
\texttt{A})~)\)</span>.</p>
<p>Using the recursive step in the definition of the function <span
class="math inline">\(rnalen\)</span>: <span
class="math display">\[rnalen(ub) = 1 + rnalen(u)\]</span> The recursive
step in the definition of the function <span
class="math inline">\(basecount\)</span> has two cases. We notice that
<span class="math inline">\(b = \texttt{A}\lor b \neq
\texttt{A}\)</span> and we proceed by cases.</p>
<p><span><em>Case i.</em></span> Assume <span class="math inline">\(b =
\texttt{A}\)</span>.</p>
<p>Using the first case in the recursive step in the definition of the
function <span class="math inline">\(basecount\)</span>: <span
class="math display">\[basecount(~(ub, \texttt{A})~) = 1 +
basecount(~(u,\texttt{A})~)\]</span> By the <span><strong>induction
hypothesis</strong></span>, we know that <span
class="math inline">\(basecount(~(u,\texttt{A})~) \leq
rnalen(u)\)</span> so: <span class="math display">\[basecount(~(ub,
\texttt{A})~) = 1 + basecount(~(u,\texttt{A})~) \leq 1 + rnalen(u) =
rnalen (ub)\]</span> and, thus, <span
class="math inline">\(basecount(~(ub,\texttt{A})~) \leq
rnalen(ub)\)</span>, as required.</p>
<p><span><em>Case ii.</em></span> Assume <span class="math inline">\(b
\neq \texttt{A}\)</span>.</p>
<p>Using the second case in the recursive step in the definition of the
function <span class="math inline">\(basecount\)</span>: <span
class="math display">\[basecount(~(ub, \texttt{A})~) =
basecount(~(u,\texttt{A})~)\]</span> By the <span><strong>induction
hypothesis</strong></span>, we know that <span
class="math inline">\(basecount(~(u,\texttt{A})~) \leq
rnalen(u)\)</span> so: <span class="math display">\[basecount(~(ub,
\texttt{A})~) = basecount(~(u,\texttt{A})~) \leq rnalen(u) &lt; 1 +
rnalen(u) = rnalen (ub)\]</span> and, thus, <span
class="math inline">\(basecount(~(ub,\texttt{A})~) \leq
rnalen(ub)\)</span>, as required.</p>
<h2 class="unnumbered" id="review">Review</h2>
<p>Recall the definitions of the functions <span
class="math inline">\(rnalen\)</span> and <span
class="math inline">\(basecount\)</span> from class.</p>
<ol>
<li><p>Select all and only options that give a witness for the
existential quantification <span class="math display">\[\exists s \in S
~(~rnalen(s) = basecount(~(s,\texttt{U})~)~)\]</span></p>
<ol>
<li><p><span class="math inline">\(\texttt{A}\)</span></p></li>
<li><p><span
class="math inline">\(\texttt{U}\texttt{U}\)</span></p></li>
<li><p><span
class="math inline">\(\texttt{C}\texttt{U}\)</span></p></li>
<li><p><span class="math inline">\((\texttt{U}, 1)\)</span></p></li>
<li><p>None of the above.</p></li>
</ol></li>
<li><p>Select all and only options that give a counterexample for the
universal quantification <span class="math display">\[\forall s \in S
~(~rnalen(s) &gt; basecount(~(s,\texttt{G})~)~)\]</span></p>
<ol>
<li><p><span class="math inline">\(\texttt{U}\)</span></p></li>
<li><p><span
class="math inline">\(\texttt{G}\texttt{G}\)</span></p></li>
<li><p><span
class="math inline">\(\texttt{A}\texttt{G}\)</span></p></li>
<li><p><span
class="math inline">\(\texttt{C}\texttt{U}\texttt{G}\)</span></p></li>
<li><p>None of the above.</p></li>
</ol></li>
<li><p>Select all and only the true statements</p>
<ol>
<li><p><span class="math inline">\(\forall s \in S ~\exists b \in B
~\left(~rnalen(s) = basecount(~(s,b)~)~ \right)\)</span></p></li>
<li><p><span class="math inline">\(\exists s \in S ~\forall b \in B
~\left(~rnalen(s) = basecount(~(s,b)~)~ \right)\)</span></p></li>
<li><p><span class="math display">\[\begin{aligned}
\forall s_1 \in S~\forall s_2 \in S ~&amp;\forall b \in B ~\big( ~\big(
rnalen(s_1) = basecount(~(s_1,b)~) \\
    &amp;\land rnalen(s_2) = basecount(~(s_2,b)~) \land rnalen(s_1) =
rnalen(s_2) \big) \to s_1 = s_2  \big)\end{aligned}\]</span></p></li>
<li><p>None of the above.</p></li>
</ol></li>
</ol>
<h1 class="unnumbered" id="wednesday-november-3">Wednesday November
3</h1>
<p>To organize our proofs, it’s useful to highlight which claims are
most important for our overall goals. We use some terminology to
describe different roles statements can have.</p>
<p><span><strong>Theorem</strong></span>: Statement that can be shown to
be true, usually an important one.</p>
<p>Less important theorems can be called
<span><strong>proposition</strong></span>,
<span><strong>fact</strong></span>,
<span><strong>result</strong></span>,
<span><strong>claim</strong></span>.</p>
<p><span><strong>Lemma</strong></span>: A less important theorem that is
useful in proving a theorem.</p>
<p><span><strong>Corollary</strong></span>: A theorem that can be proved
directly after another one has been proved, without needing a lot of
extra work.</p>
<p><span><strong>Invariant</strong></span>: A theorem that describes a
property that is true about an algorithm or system no matter what inputs
are used.</p>
<div class="center">
<p><img src="../../resources/images/robot-grid.png" style="width:3in"
alt="image" /></p>
</div>
<p><span><strong>Theorem</strong></span>: A robot on an infinite
2-dimensional integer grid starts at <span
class="math inline">\((0,0)\)</span> and at each step moves to
diagonally adjacent grid point. This robot can / cannot
<span>(<span><em>circle one</em></span>)</span> reach <span
class="math inline">\((1,0)\)</span>.</p>
<p><span><strong>Definition</strong></span> The set of positions the
robot can visit <span class="math inline">\(P\)</span> is defined by:
<span class="math display">\[\begin{array}{ll}
    \textrm{Basis Step: } &amp; (0,0) \in P \\
    \textrm{Recursive Step: } &amp; \textrm{If } (x,y) \in P  \textrm{,
then }
    \phantom{(x+1, y+1), (x+1, y-1), (x-1, y-1), (x-1, y+1)} \textrm{
are also in } P
\end{array}\]</span></p>
<p><span><em>Example elements of <span class="math inline">\(P\)</span>
are</em></span>:</p>
<p><span><strong>Lemma</strong></span>: <span
class="math inline">\(\forall (x,y) \in P( x+y \textrm{ is an even
integer}~)\)</span></p>
<p><span><em>Why are we calling this a lemma?</em></span></p>
<p>Proof of theorem using lemma: To show is <span
class="math inline">\((1,0) \notin P\)</span>. Rewriting the lemma to
explicitly restrict the domain of the universal, we have <span
class="math inline">\(\forall (x,y) ~(~ (x,y) \in P  \to (x+y \textrm{
is an even integer})~)\)</span>. Since the universal is true, <span
class="math inline">\((~ (1,0) \in P \to (1+0 \textrm{ is an even
integer})~)\)</span> is a true statement. Evaluating the conclusion of
this conditional statement: By definition of long division, since <span
class="math inline">\(1 = 0 \cdot 2 + 1\)</span> (where <span
class="math inline">\(0 \in \mathbb{Z}\)</span> and <span
class="math inline">\(1 \in \mathbb{Z}\)</span> and <span
class="math inline">\(0 \leq 1 &lt; 2\)</span> mean that <span
class="math inline">\(0\)</span> is the quotient and <span
class="math inline">\(1\)</span> is the remainder), <span
class="math inline">\(1 ~\textrm{\bf mod}~ 2 = 1\)</span> which is not
<span class="math inline">\(0\)</span> so the conclusion is false. A
true conditional with a false conclusion must have a false hypothesis.
Thus, <span class="math inline">\((1,0) \notin P\)</span>, QED. <span
class="math inline">\(\square\)</span></p>
<p>Proof of lemma by structural induction:</p>
<p><span><strong>Basis Step</strong></span>:</p>
<p><span><strong>Recursive Step</strong></span>: Consider arbitrary
<span class="math inline">\((x,y) \in P\)</span>. To show is: <span
class="math display">\[(x+y \text{ is an even integer}) \to (\text{sum
of coordinates of next position is even integer})\]</span> Assume
<span><strong>as the induction hypothesis, IH</strong></span> that:</p>
<p>The set <span class="math inline">\(\mathbb{N}\)</span> is
recursively defined. Therefore, the function <span
class="math inline">\(sumPow: \mathbb{N} \to \mathbb{N}\)</span> which
computes, for input <span class="math inline">\(i\)</span>, the sum of
the nonnegative powers of <span class="math inline">\(2\)</span> up to
and including exponent <span class="math inline">\(i\)</span> is defined
recursively by</p>
<p><span class="math display">\[\begin{aligned}
{2}
    \text{Basis step:  } \qquad &amp; sumPow(0) = 1 &amp;\\
    \text{Recursive step:  } &amp; \text{If } x \in \mathbb{N} \text{,
then } &amp;sumPow(x+1) = sumPow(x) + 2^{x+1}\end{aligned}\]</span></p>
<p><span class="math inline">\(sumPow(0) =\)</span></p>
<p><span class="math inline">\(sumPow(1) =\)</span></p>
<p><span class="math inline">\(sumPow(2) =\)</span></p>
<p>Fill in the blanks in the following proof of <span
class="math display">\[\forall n \in \mathbb{N}~(sumPow(n) = 2^{n+1} -
1)\]</span></p>
<p><span><strong>Proof</strong></span>: Since <span
class="math inline">\(\mathbb{N}\)</span> is recursively defined, we
proceed by <u></u>.</p>
<p><span><strong>Basis case</strong></span>: We need to show that
<u></u>. Evaluating each side: <span class="math inline">\(LHS =
sumPow(0) = 1\)</span> by the basis case in the recursive definition of
<span class="math inline">\(sumPow\)</span>; <span
class="math inline">\(RHS = 2^{0+1} - 1 = 2^1 - 1 = 2-1 = 1\)</span>.
Since <span class="math inline">\(1=1\)</span>, the equality holds.</p>
<p><span><strong>Recursive case</strong></span>: Consider arbitrary
natural number <span class="math inline">\(n\)</span> and assume, as the
<u></u> that <span class="math inline">\(sumPow(n) = 2^{n+1} -
1\)</span>. We need to show that <u></u>. Evaluating each side: <span
class="math display">\[LHS = sumPow(n+1) \overset{\text{rec def}}{=}
sumPow(n)  + 2^{n+1}\overset{\text{IH}}{=} (2^{n+1} - 1) +
2^{n+1}.\]</span> <span class="math display">\[RHS = 2^{(n+1)+1}- 1
\overset{\text{exponent rules}}{=} 2 \cdot 2^{n+1} -1  = \left(2^{n+1} +
2^{n+1} \right) - 1
\overset{\text{regrouping}}{=}  (2^{n+1} - 1) + 2^{n+1}\]</span> Thus,
<span class="math inline">\(LHS = RHS\)</span>. The structural induction
is complete and we have proved the universal generalization. <span
class="math inline">\(\square\)</span></p>
<h2 class="unnumbered" id="review-1">Review</h2>
<ol>
<li><p><br />
</p>
<p>Recall the set <span class="math inline">\(P\)</span> defined by the
recursive definition <span class="math display">\[\begin{array}{ll}
    \textrm{Basis Step: } &amp; (0,0) \in P\\
     \textrm{Recursive Step: } &amp; \textrm{If } (x,y) \in P \textrm{
then }
     (x+1, y+1) \in P \textrm{ and } (x+1, y-1) \in P \textrm{ and }\\
     &amp; (x-1,y-1) \in P
     \textrm{ and } (x-1, y+1) \in P
\end{array}\]</span></p>
<ol>
<li><p>Select all and only the ordered pairs below that are elements of
<span class="math inline">\(P\)</span></p>
<ol>
<li><p><span class="math inline">\((0,0)\)</span></p></li>
<li><p><span class="math inline">\((4,0)\)</span></p></li>
<li><p><span class="math inline">\((1,1)\)</span></p></li>
<li><p><span class="math inline">\((1.5,2.5)\)</span></p></li>
<li><p><span class="math inline">\((0, -2)\)</span></p></li>
</ol></li>
<li><p>What is another description of the set <span
class="math inline">\(P\)</span> ? (Select all and only the true
descriptions.)</p>
<ol>
<li><p><span class="math inline">\(\mathbb{Z} \times
\mathbb{Z}\)</span></p></li>
<li><p><span class="math inline">\(\{ (n,n) ~|~ n \in \mathbb{Z}
\}\)</span></p></li>
<li><p><span class="math inline">\(\{ (a,b) \in \mathbb{Z} \times
\mathbb{Z} ~|~ (a+b) \textbf{ mod } 2 =0 \}\)</span></p></li>
</ol></li>
</ol></li>
<li><p><br />
</p>
<p>Select all and only the true statements below about the relationship
between structural induction and mathematical induction.</p>
<ol>
<li><p>Both structural induction and mathematical induction are proof
strategies that may be useful when proving universal claims about
recursively defined sets.</p></li>
<li><p>Mathematical induction is a special case of structural induction,
for the case when the domain of quantification is <span
class="math inline">\(\{ n \in \mathbb{Z} \mid n \geq b\}\)</span> for
some integer <span class="math inline">\(b\)</span>.</p></li>
<li><p>Universal claims about the set of all integers may be proved
using structural induction but not using mathematical
induction.</p></li>
</ol></li>
<li><p><br />
</p>
<p>Consider the following function definitions <span
class="math display">\[2^n: \mathbb{N} \to \mathbb{N} \text{ given by }
2^0 = 1 ~~\text{ and }~~
    2^{n+1} = 2 \cdot 2^n\]</span> <span class="math display">\[n!:
\mathbb{N} \to \mathbb{N} \text{ given by } 0! = 1 ~~\text{ and }~~
    (n+1)! = (n+1) n!\]</span></p>
<ol>
<li><p>Select all and only true statements below:</p>
<ol>
<li><p><span class="math inline">\(2^0 &lt; 0!\)</span></p></li>
<li><p><span class="math inline">\(2^1 &lt; 1!\)</span></p></li>
<li><p><span class="math inline">\(2^2 &lt; 2!\)</span></p></li>
<li><p><span class="math inline">\(2^3 &lt; 3!\)</span></p></li>
<li><p><span class="math inline">\(2^4 &lt; 4!\)</span></p></li>
<li><p><span class="math inline">\(2^5 &lt; 5!\)</span></p></li>
<li><p><span class="math inline">\(2^6 &lt; 6!\)</span></p></li>
<li><p><span class="math inline">\(2^7 &lt; 7!\)</span></p></li>
</ol></li>
<li><p>Fill in the blanks in the following proof.</p>
<p><span><strong>Claim</strong></span>: For all integers <span
class="math inline">\(n\)</span> greater than or equal to <span
class="math inline">\(4\)</span>, <span class="math inline">\(2^n &lt;
n!\)</span><br />
<span><strong>Proof</strong></span>: We proceed by mathematical
induction on the set of integers greater than or equal to <span
class="math inline">\(4\)</span>.</p>
<p><span><strong>Basis step</strong></span>: Using the <u>BLANK 1</u>,
<span class="math display">\[2^4 = 2 \cdot 2^3 = 2 \cdot 2 \cdot 2^2 = 2
\cdot 2 \cdot 2 \cdot 2^1 =
    2 \cdot 2 \cdot 2 \cdot 2 \cdot 2^0 =
    2 \cdot 2 \cdot 2 \cdot 2 \cdot 1 = 16\]</span> and <span
class="math display">\[4! = 4 \cdot 3! = 4 \cdot 3 \cdot 2!
    = 4 \cdot 3 \cdot 2 \cdot 1! = 4 \cdot 3 \cdot 2 \cdot 1 \cdot 0!
    = 4 \cdot 3 \cdot 2 \cdot 1 \cdot 1 = 24\]</span> Since <span
class="math inline">\(16 &lt; 24\)</span>, we have proved that <span
class="math inline">\(2^4 &lt; 4!\)</span> , as required.<br />
<span><strong>Recursive step</strong></span>: Consider an arbitrary
integer <span class="math inline">\(k\)</span> that is greater than or
equal to <span class="math inline">\(4\)</span> and assume as the
<u>BLANK 2</u>, that <span class="math inline">\(2^k &lt; k!\)</span> .
We want to show that <span class="math inline">\(2^{k+1} &lt;
(k+1)!\)</span> . <span class="math display">\[\begin{aligned}
    2^{k+1} &amp;= 2 \cdot 2^{k} \qquad \text{by
}\underline{\hspace{0.2in}BLANK 3\hspace{0.2in}}\\
        &amp;&lt; 2 \cdot k! \qquad \text{by
}\underline{\hspace{0.2in}BLANK 4\hspace{0.2in}}\\
        &amp;&lt; k \cdot k! \qquad \text{by
}\underline{\hspace{0.2in}BLANK 5\hspace{0.2in}}\\
        &amp;&lt; (k+1) \cdot k!  \qquad \text{by
}\underline{\hspace{0.2in}BLANK 6\hspace{0.2in}}\\
        &amp;= (k+1)!  \qquad \text{by }\underline{\hspace{0.2in}BLANK
7\hspace{0.2in}}\\\end{aligned}\]</span> as required.</p>
<ol>
<li><p>properties of addition, multiplication, and <span
class="math inline">\(&lt;\)</span> for real numbers</p></li>
<li><p>definitions of the functions <span
class="math inline">\(2^n\)</span> and <span
class="math inline">\(n!\)</span></p></li>
<li><p>definition of <span class="math inline">\(k\)</span></p></li>
<li><p>induction hypothesis</p></li>
</ol></li>
</ol></li>
</ol>
<h1 class="unnumbered" id="friday-november-5">Friday November 5</h1>
<p><span><strong>Definition</strong></span> The set of linked lists of
natural numbers <span class="math inline">\(L\)</span> is defined
recursively by <span class="math display">\[\begin{array}{ll}
    \textrm{Basis Step: } &amp; [] \in L \\
    \textrm{Recursive Step: } &amp; \textrm{If } l \in L\textrm{ and }n
\in \mathbb{N} \textrm{, then } (n, l) \in L
\end{array}\]</span></p>
<p>Visually:</p>
<p>Example: the list with two nodes whose first node has <span
class="math inline">\(20\)</span> and whose second node has <span
class="math inline">\(42\)</span></p>
<p><span><strong>Definition</strong></span>: The length of a linked list
of natural numbers <span class="math inline">\(L\)</span>, <span
class="math inline">\(length: L \to \mathbb{N}\)</span> is defined by
<span class="math display">\[\begin{array}{llll}
\textrm{Basis Step:} &amp;  &amp; length(~[]~) &amp;= 0 \\
\textrm{Recursive Step:} &amp; \textrm{If } l \in L\textrm{ and }n \in
\mathbb{N}\textrm{, then  } &amp; length(~(n, l)~)  &amp;= 1+ length(l)
\end{array}\]</span></p>
<p><span><strong>Definition</strong></span>: The function <span
class="math inline">\(prepend : L \times \mathbb{N} \to L\)</span> that
adds an element at the front of a linked list is defined by <span
class="math display">\[\phantom{prepend(~(l, n)~) = (n, l)}\]</span></p>
<p><span><strong>Definition</strong></span> The function <span
class="math inline">\(append : L \times \mathbb{N} \to L\)</span> that
adds an element at the end of a linked list is defined by <span
class="math display">\[\begin{array}{llll}
\textrm{Basis Step:} &amp; \textrm{If } m \in \mathbb{N}\textrm{ then }
&amp; \phantom{append(~([], m)~)} &amp; \phantom{= (m, []) }\\
\textrm{Recursive Step:} &amp; \textrm{If } l \in L\textrm{ and }n \in
\mathbb{N}\textrm{ and }m \in \mathbb{N}\textrm{, then  } &amp;
\phantom{append(~(~(n, l), m~)~) } &amp;\phantom{= (n, append(~(l,
m)~)~)}
\end{array}\]</span></p>
<p><span><strong>Claim</strong></span>: <span
class="math inline">\(\forall l \in L ~ (~length(~append(~(l, 100)~)~)
&gt; length(l)~)\)</span></p>
<p><span><strong>Proof:</strong></span> By structural induction on <span
class="math inline">\(L\)</span>, we have two cases:</p>
<p><span><strong>Basis Step</strong></span></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">1. <strong>To Show</strong> <span
class="math inline">\(length(~append(~([], 100)~)~) &gt;
length(~[]~)\)</span></td>
<td style="text-align: left;">Because <span
class="math inline">\([]\)</span> is the only element defined in the
basis step of <span class="math inline">\(L\)</span>, we only need to
prove that the property holds for <span
class="math inline">\([]\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">2. <strong>To Show</strong> <span
class="math inline">\(length(~(100,[])~) &gt; length(~[]~)\)</span></td>
<td style="text-align: left;">By basis step in definition of <span
class="math inline">\(append\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">3. <strong>To Show</strong> <span
class="math inline">\((1 +length(~[]~)) &gt; length(~[]~)\)</span></td>
<td style="text-align: left;">By recursive step in definition of <span
class="math inline">\(length\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">4. <strong>To Show</strong> <span
class="math inline">\(1+0 &gt; 0\)</span></td>
<td style="text-align: left;">By basis step in definition of <span
class="math inline">\(length\)</span>.</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">5. <span
class="math inline">\(T\)</span></td>
<td style="text-align: left;">By properties of integers</td>
</tr>
<tr class="even">
<td style="text-align: left;"></td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">QED</td>
<td style="text-align: left;">Because we got to <span
class="math inline">\(T\)</span> only by rewriting <strong>To
Show</strong> to equivalent statements, using well-defined proof
techniques, and applying definitions.</td>
</tr>
</tbody>
</table>
<p><span><strong>Recursive Step</strong></span></p>
<p>Consider an arbitrary: <span class="math inline">\(l&#39; \in
L\)</span>, <span class="math inline">\(n \in \mathbb{N}\)</span>, and
we assume as the <span><strong>induction hypothesis</strong></span>
that: <span class="math display">\[length(~append(~(l&#39;, 100~)~)~)
&gt; length(l&#39;)\]</span> Our goal is to show that <span
class="math inline">\(length(~append( ~(~(n,l&#39;), 100~)~)~) &gt;
length(~(n,l&#39;)~)\)</span> is also true. We start by working with one
side of the candidate inequality: <span
class="math display">\[\begin{aligned}
LHS &amp;= length(~append( ~(~ (n,l&#39;), 100~)~)~) \\
&amp;= length(~(n, append(~(l&#39;, 100)~)~ )~) \qquad \text{by the
recursive definition of $append$}\\
&amp;= 1 + length(~ append(~(l&#39;, 100)~) ~) \qquad \text{by the
recursive definition of $length$}\\
&amp;&gt; 1+ length(l&#39;)  \qquad \text{by the induction hypothesis}\\
&amp;= length( (n,l&#39;) )  \qquad \text{by the recursive definition of
$length$}\\
&amp;= RHS \end{aligned}\]</span></p>
<p>Prove or disprove: <span class="math inline">\(\forall n \in
\mathbb{N} ~\exists l \in L ~(~length(l) = n~)\)</span></p>
<h2 class="unnumbered" id="review-2">Review</h2>
<p>Recall the definition of linked lists from class.</p>
<p>Consider this (incomplete) definition:</p>
<p><span><strong>Definition</strong></span> The function <span
class="math inline">\(\textit{increment} :
\underline{\hspace{6em}}\)</span> that adds 1 to the data in each node
of a linked list is defined by: <span
class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{increment} : \underline{\hspace{3em}} &amp; \to
\underline{\hspace{3em}} \\
\textrm{Basis Step:} &amp; &amp; \textit{increment}([]) &amp; = [] \\
\textrm{Recursive Step:} &amp; \textrm{If } l \in L, n \in \mathbb{N}
&amp; \textit{increment}((n, l)) &amp; = (1 + n, \textit{increment}(l))
\end{array}\]</span></p>
<p>Consider this (incomplete) definition:</p>
<p><span><strong>Definition</strong></span> The function <span
class="math inline">\(\textit{sum} : L \to \mathbb{N}\)</span> that adds
together all the data in nodes of the list is defined by: <span
class="math display">\[\begin{array}{llll}
&amp; &amp; \textit{sum} : L &amp; \to \mathbb{N} \\
\textrm{Basis Step:} &amp; &amp; \textit{sum}([]) &amp; = 0 \\
\textrm{Recursive Step:} &amp; \textrm{If } l \in L, n \in \mathbb{N}
&amp; \textit{sum}((n, l)) &amp; = \underline{\hspace{8em}}
\end{array}\]</span></p>
<p>You will compute a sample function application and then fill in the
blanks for the domain and codomain of each of these functions.</p>
<ol>
<li><p>Based on the definition, what is the result of <span
class="math inline">\(\textit{increment}((4, (2, (7, []))))\)</span>?
Write your answer directly with no spaces.</p></li>
<li><p>Which of the following describes the domain and codomain of
<em>increment</em>?</p>
<div class="multicols">
<p><span>2</span></p>
<ol>
<li><p>The domain is <span class="math inline">\(L\)</span> and the
codomain is <span class="math inline">\(\mathbb{N}\)</span></p></li>
<li><p>The domain is <span class="math inline">\(L\)</span> and the
codomain is <span class="math inline">\(\mathbb{N} \times
L\)</span></p></li>
<li><p>The domain is <span class="math inline">\(L \times
\mathbb{N}\)</span> and the codomain is <span
class="math inline">\(L\)</span></p></li>
<li><p>The domain is <span class="math inline">\(L \times
\mathbb{N}\)</span> and the codomain is <span
class="math inline">\(\mathbb{N}\)</span></p></li>
<li><p>The domain is <span class="math inline">\(L\)</span> and the
codomain is <span class="math inline">\(L\)</span></p></li>
<li><p>None of the above</p></li>
</ol>
</div></li>
<li><p>Assuming we would like <span class="math inline">\(sum((5, (6,
[])))\)</span> to evaluate to <span class="math inline">\(11\)</span>
and <span class="math inline">\(sum((3, (1, (8, []))))\)</span> to
evaluate to <span class="math inline">\(12\)</span>, which of the
following could be used to fill in the definition of the recursive case
of <em>sum</em>?</p>
<div class="multicols">
<p><span>2</span></p>
<ol>
<li><p><span class="math inline">\(\begin{cases}
            1 + \textit{sum}(l) &amp; \textrm{when } n \neq 0 \\
            \textit{sum}(l) &amp; \textrm{when } n = 0 \\
        \end{cases}\)</span></p></li>
<li><p><span class="math inline">\(1 + \textit{sum}(l)\)</span></p></li>
<li><p><span class="math inline">\(n +
\textit{increment}(l)\)</span></p></li>
<li><p><span class="math inline">\(n + \textit{sum}(l)\)</span></p></li>
<li><p>None of the above</p></li>
</ol>
</div></li>
<li><p>Choose only and all of the following statements that are
<strong>well-defined</strong>; that is, they correctly reflect the
domains and codomains of the functions and quantifiers, and respect the
notational conventions we use in this class. Note that a well-defined
statement may be true or false.</p>
<div class="multicols">
<p><span>2</span></p>
<ol>
<li><p><span class="math inline">\(\forall l \in L \,
(\textit{sum}(l))\)</span></p></li>
<li><p><span class="math inline">\(\exists l \in L \, (\textit{sum}(l)
\land \textit{length}(l))\)</span></p></li>
<li><p><span class="math inline">\(\forall l \in L \,
(\textit{sum}(\textit{increment}(l)) = 10)\)</span></p></li>
<li><p><span class="math inline">\(\exists l \in L \,
(\textit{sum}(\textit{increment}(l)) = 10)\)</span></p></li>
<li><p><span class="math inline">\(\forall l \in L \, \forall n \in
\mathbb{N} \, ((n \times l) \subseteq L)\)</span></p></li>
<li><p><span class="math inline">\(\forall l_1 \in L \, \exists l_2 \in
L \, (\textit{increment}(\textit{sum}(l_1)) = l_2)\)</span></p></li>
<li><p><span class="math inline">\(\forall l \in L \,
(\textit{length}(\textit{increment}(l)) =
\textit{length}(l))\)</span></p></li>
</ol>
</div></li>
<li><p>Choose only and all of the statements in the previous part that
are both well-defined and true.</p></li>
</ol>
</body>
</html>
